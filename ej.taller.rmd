---
title: "Estadística descriptiva con datos espaciales"
# author: "Adrián Jové"
output: 
  rmarkdown::github_document:
    fig_width: 10
    fig_height: 6
---

En el taller se estuvo trabajando con un archivo en formato .csv sobre algas en la región de California,  estudiando sus características según los datos disponibles.
Para ello se dispuso de una rutina en el repositorio del taller y se puso en funcionamiento.
Lo que se intenta realizar en esta rutina, es poner en funcionamiento la rutina con datos propios. 
Los datos propios corresponden a la pesquería de corvina en Argentina. La corvina pertenece al grupo variado costero. 
Se realizaron en los años 2016, 2017, 2018, 2019, 2023 y 2025 campañas de
investigación en la Bahía de Samborombón a bordo de embarcaciones menores de INIDEP. 
Para poner en funcionamiento la rutina, se consideraron del archivo de datos las variables
longitud (lon), latitud (lat), tf (temperatura en el fondo), sf (salinidad en el fondo), cavcorvkg  (captura de corvina por kilo), indicejun (indice de abundancia de juveniles)



```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
packages = c("sf", "spdep", "spatialreg", "vioplot", "corrplot", "ggplot2")

# instalar paquetes faltantes

library(dplyr)
library(readxl)
library(spdep)   # datos espaciales
library(sf)      # datos espaciales
library(spatialreg) # modelos SAR/SEM
library(vioplot)   # gráficos de violín
library(corrplot)  # gráficos de correlación 
library(ggplot2)

# 1. Verificar si units está realmente instalado
library(units)


# 4. Luego cargar sf
library(sf)


" - - - - - - - - - - - - -  CARGAR DATOS  - - - - - - - - - - - - - - - - - - "



# Cargar datos
dm=read_excel("Datos juveniles corvina.xlsx")

summary(dm)  # resumen estadístico

'Aquí pasaremos nuestros datos a formato numérico para poder trabajarlos y construimos un dataframe'

anio       =as.numeric(dm$Anio)
lon        =as.numeric(dm$lon)
lat        =as.numeric(dm$lat)
tf         =as.numeric(dm$tf)
sf         =as.numeric(dm$sf)
capcorvkg  =as.numeric(dm$cap_cor_kg)
indicejun  =as.numeric(dm$n_juv_e1)

dm=data.frame(anio,lon,lat,tf,sf,capcorvkg,indicejun)

```

Tal como vimos en el curso, aquí tenemos para cada variable su histograma y boxplot. Primero consideramos los datos juntando todos los años, luego haremos cada gráfico por separado por año.


```{r graphs1, echo=F}

for (i in 1:length(colnames(dm))){
  par(mfrow = c(1,2))   # 1 fila y 2 columnas
  n <- names(dm)[i]
  # Histograma
  hist(dm[, i], main = "", xlab = n,  col = "lightblue")
  
  # Boxplot
  boxplot(dm[, i], main = "", horizontal = TRUE, col = "plum")
}

```
Aquí vemos gráficos de violín

```{r graphs2, echo=F}
# Graficos de violín
par(mfrow=c(1,4)) # presentar 4 gráficos en 1 fila, 4 columnas
vioplot(tf, col = "lightblue"   , main="Temperatura en el fondo", horizontal= TRUE)
vioplot(sf,   col = "darkseagreen", main="Salinidad")
vioplot(capcorvkg,      col = "lightpink"   , main="Captura de corvina por kilo")
vioplot(indicejun,      col = "red"   , main="indicejun")
par(mfrow=c(1,1))  # volver a 1 gráfico

```


Aquí podemos observar la matriz y el gráfico de correlaciones entre variables. La mayor
correlación se da entre la captura de corvina por kilo e índice de juveniles



```{r graphs3, echo=F}
# Gráficos de dispersión
(cor_mat = cor(dm[,4:7])) # Matriz de correlaciones

pairs(dm[,4:7], pch=19, col="tan")


# Visualización con corrplot
corrplot(cor_mat, method = "circle", type = "upper",
         col = colorRampPalette(c("orangered", "white", "mediumseagreen"))(200),
         tl.col = "darkslateblue", tl.srt = 45, 
         addCoef.col = "midnightblue", number.cex = 0.8)

```

```{r, include=FALSE}
# Convertir a objeto espacial (CRS WGS84)
dm_sp = st_as_sf(dm, coords = c("lon", "lat"), crs = 4326)
```

Gráfico de capturas de corvina considerando los 6 años de estudio juntos

```{r graphs4, echo=F}
#Gráfico simple. El gradiente de color va de menor a mayor altura
plot(dm_sp["capcorvkg"], main = "capcorvkg", pch=18, axes=T)
```


```{r, include=FALSE}
# Definir límites 
xlim = c(min(dm$lon) - 0.2, max(dm$lon) + 0.2)
ylim = c(min(dm$lat) - 0.2, max(dm$lat) + 0.2)
```


```{r, include=FALSE}
# Aseguramos que 'anio' sea un factor
dm$anio <- as.factor(dm$anio)

# Mapa base (data.frame con polígonos del mundo)
world <- map_data("world")

# Definir límites del mapa
xlim <- c(min(dm$lon) - 0.2, max(dm$lon) + 0.2)
ylim <- c(min(dm$lat) - 0.2, max(dm$lat) + 0.2)
```

Mapas de lances y captura de corvina por año

```{r graphs5, echo=F}
# Gráfico facetado. 
ggplot() +
  geom_polygon(data = world, aes(x = long, y = lat, group = group),
               fill = "gray90", colour = "gray70") +
  geom_point(data = dm,
             aes(x = lon, y = lat, colour = capcorvkg),
             size =3) +
  scale_color_gradient(low = "lightblue", high = "darkred") +
  coord_quickmap(xlim = xlim, ylim = ylim, expand = FALSE) +
  facet_wrap(~ anio, labeller = labeller(anio = c(
    "1" = "2016",
    "2" = "2017",
    "3" = "2018",
    "4" = "2019",
    "5" = "2023",
    "6" = "2025"
  ))) +
  labs(title = "captura de corvina por kg",
       x = "Longitud", y = "Latitud", colour = "capcorvkg") +
  theme_minimal()


```

Graficamos por año sf 


```{r graphs6, echo=F}
ggplot() +
  geom_polygon(data = world, aes(x = long, y = lat, group = group),
               fill = "gray90", colour = "gray70") +
  geom_point(data = dm,
             aes(x = lon, y = lat,
                 colour = sf,
                 size   = sf),      # tamaño mapeado estéticamente
             alpha = 0.8) +        # leve transparencia para mejor lectura
  scale_color_viridis_c(name = "sf (color)") +
  scale_size_continuous(name = "sf (tamaño)",
                        range = c(1, 6)) +   # control del rango visual
  coord_quickmap(xlim = xlim, ylim = ylim, expand = FALSE)+
  facet_wrap(~ anio, labeller = labeller(anio = c(
    "1" = "2016",
    "2" = "2017",
    "3" = "2018",
    "4" = "2019",
    "5" = "2023",
    "6" = "2025"
  ))) +
  labs(title = "Distribución del salinidad por año",
       x = "Longitud", y = "Latitud") +
  theme_minimal() +
  theme(
    legend.position = "right",
    strip.text = element_text(face = "bold")
  )

```

Graficamos por año  tf  

```{r graphs7, echo=F}

ggplot() +
  geom_polygon(data = world, aes(x = long, y = lat, group = group),
               fill = "gray90", colour = "gray70") +
  geom_point(data = dm,
             aes(x = lon, y = lat,
                 colour = tf,
                 size   = tf),      # tamaño mapeado estéticamente
             alpha = 0.8) +        # leve transparencia para mejor lectura
  scale_color_viridis_c(name = "tf (color)") +
  scale_size_continuous(name = "tf (tamaño)",
                        range = c(1, 6)) +   # control del rango visual
  coord_quickmap(xlim = xlim, ylim = ylim, expand = FALSE) +
  facet_wrap(~ anio, labeller = labeller(anio = c(
    "1" = "2016",
    "2" = "2017",
    "3" = "2018",
    "4" = "2019",
    "5" = "2023",
    "6" = "2025"
  ))) +
  labs(title = "Distribución del tf por año",
       x = "Longitud", y = "Latitud") +
  theme_minimal() +
  theme(
    legend.position = "right",
    strip.text = element_text(face = "bold")
  )

```


```{r graphs8, echo=F}
# Gráfico facetado
ggplot() +
  geom_polygon(data = world, aes(x = long, y = lat, group = group),
               fill = "gray90", colour = "gray70") +
  geom_point(data = dm,
             aes(x = lon, y = lat, colour = tf),
             size =3) +
  scale_color_gradient(low = "lightblue", high = "darkred") +
  coord_quickmap(xlim = xlim, ylim = ylim, expand = FALSE) +
  facet_wrap(~ anio, labeller = labeller(anio = c(
    "1" = "2016",
    "2" = "2017",
    "3" = "2018",
    "4" = "2019",
    "5" = "2023",
    "6" = "2025"
  ))) +
  labs(title = "Distribución del índice por año",
       x = "Longitud", y = "Latitud", colour = "tf") +
  theme_minimal()

```


Ahora calculamos los cuartiles capcorvkg por año 

```{r, include=FALSE}
cuartiles <- quantile(dm$capcorvkg, probs = seq(0, 1, 0.25), na.rm = TRUE)
print(cuartiles)

# Crear columna de cuartil correspondiente
dm <- dm %>%
  mutate(cuartil = cut(capcorvkg,
                       breaks = cuartiles,
                       include.lowest = TRUE,
                       labels = c("Q1", "Q2", "Q3", "Q4")))

# Cargar mapa base del mundo
world <- map_data("world")

# Definir límites del mapa (con un pequeño margen)
xlim <- c(min(dm$lon) - 0.2, max(dm$lon) + 0.2)
ylim <- c(min(dm$lat) - 0.2, max(dm$lat) + 0.2)

```


```{r graphs9, echo=F}
# Gráfico facetado por año, coloreado por cuartil
ggplot() +
  geom_polygon(data = world, aes(x = long, y = lat, group = group),
               fill = "gray90", colour = "gray70") +
  geom_point(data = dm,
             aes(x = lon, y = lat, colour = cuartil),
             size = 2, alpha = 0.9) +
  scale_color_brewer(palette = "RdYlBu", direction = -1, name = "Cuartiles\n(capcorvkg)") +
  coord_quickmap(xlim = xlim, ylim = ylim, expand = FALSE)+
  facet_wrap(~ anio, labeller = labeller(anio = c(
    "1" = "2016",
    "2" = "2017",
    "3" = "2018",
    "4" = "2019",
    "5" = "2023",
    "6" = "2025"
  )))+
  labs(title = "Distribución espacial de captura de corvina x kg por cuartiles y año",
       x = "Longitud", y = "Latitud") +
  theme_minimal() +
  theme(
    panel.grid = element_line(colour = "gray80", size = 0.2),
    strip.text = element_text(face = "bold"),
    legend.position = "right"
  )

```



También se puede replicar a tf y sf

```{r, include=FALSE}
# Calcular los cuartiles capcorvkg por año (opcionalmente podrías hacerlo por año)
cuartiles <- quantile(dm$tf, probs = seq(0, 1, 0.25), na.rm = TRUE)
print(cuartiles)

# Crear columna de cuartil correspondiente
dm <- dm %>%
  mutate(cuartil = cut(tf,
                       breaks = cuartiles,
                       include.lowest = TRUE,
                       labels = c("Q1", "Q2", "Q3", "Q4")))

# Cargar mapa base del mundo
world <- map_data("world")

# Definir límites del mapa (con un pequeño margen)
xlim <- c(min(dm$lon) - 0.2, max(dm$lon) + 0.2)
ylim <- c(min(dm$lat) - 0.2, max(dm$lat) + 0.2)

```

```{r graphs10, echo=F}

# Gráfico facetado por año, coloreado por cuartil
ggplot() +
  geom_polygon(data = world, aes(x = long, y = lat, group = group),
               fill = "gray90", colour = "gray70") +
  geom_point(data = dm,
             aes(x = lon, y = lat, colour = cuartil),
             size = 2, alpha = 0.9) +
  scale_color_brewer(palette = "RdYlBu", direction = -1, name = "Cuartiles\n(tf)") +
  coord_quickmap(xlim = xlim, ylim = ylim, expand = FALSE)+
  facet_wrap(~ anio, labeller = labeller(anio = c(
    "1" = "2016",
    "2" = "2017",
    "3" = "2018",
    "4" = "2019",
    "5" = "2023",
    "6" = "2025"
  )))+
  labs(title = "Distribución espacial de temperatura en el fondo por cuartiles y año",
       x = "Longitud", y = "Latitud") +
  theme_minimal() +
  theme(
    panel.grid = element_line(colour = "gray80", size = 0.2),
    strip.text = element_text(face = "bold"),
    legend.position = "right"
  )
```

Por último, lo aplicamos a la salinidad

```{r, include=FALSE}
# Calcular los cuartiles capcorvkg por año (opcionalmente podrías hacerlo por año)
cuartiles <- quantile(dm$sf, probs = seq(0, 1, 0.25), na.rm = TRUE)
print(cuartiles)

# Crear columna de cuartil correspondiente
dm <- dm %>%
  mutate(cuartil = cut(sf,
                       breaks = cuartiles,
                       include.lowest = TRUE,
                       labels = c("Q1", "Q2", "Q3", "Q4")))

# Cargar mapa base del mundo
world <- map_data("world")

# Definir límites del mapa (con un pequeño margen)
xlim <- c(min(dm$lon) - 0.2, max(dm$lon) + 0.2)
ylim <- c(min(dm$lat) - 0.2, max(dm$lat) + 0.2)

```


```{r graphs11, echo=F}
# Gráfico facetado por año, coloreado por cuartil
ggplot() +
  geom_polygon(data = world, aes(x = long, y = lat, group = group),
               fill = "gray90", colour = "gray70") +
  geom_point(data = dm,
             aes(x = lon, y = lat, colour = cuartil),
             size = 2, alpha = 0.9) +
  scale_color_brewer(palette = "RdYlBu", direction = -1, name = "Cuartiles\n(sf)") +
  coord_quickmap(xlim = xlim, ylim = ylim, expand = FALSE)+
  facet_wrap(~ anio, labeller = labeller(anio = c(
    "1" = "2016",
    "2" = "2017",
    "3" = "2018",
    "4" = "2019",
    "5" = "2023",
    "6" = "2025"
  )))+
  labs(title = "Distribución espacial de salinidad por cuartiles y año",
       x = "Longitud", y = "Latitud") +
  theme_minimal() +
  theme(
    panel.grid = element_line(colour = "gray80", size = 0.2),
    strip.text = element_text(face = "bold"),
    legend.position = "right"
  )


```

Lo que se puede apreciar en los gráficos es que las mayores capturas de corvina se 
encontraron en el año 2017, donde a su vez hubo temperaturas más altas y menor salinidad.
Las menores capturas estuvieron en los años 2023 y 2025, años donde hubo mayor salinidad.